#include <stdio.h>
#include <string.h>
#include "rsaeuro.h"		/* Required Prototypes */

#include "rsa.c"
/* Implement these simple routines as macros */

#define ReadClose(file) \
{               \
	fclose (file);\
}


#define WriteClose(file) \
{                   \
	if(file != stdout)\
		fclose(file);   \
}

#define PrintMessage(message) \
{                 \
	puts(message);  \
	fflush(stdout); \
}

/* Use one key from RSADSI's RSAREF(tm) RDEMO for comptiblity testing.
	 This ensures that both RSAEURO and RSAREF(tm) code is compatible.
*/

static R_RSA_PUBLIC_KEY PUBLIC_KEY1 = {
	512,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0xc0, 0x76, 0x47, 0x97, 0xb8, 0xbe, 0xc8, 0x97,
	 0x2a, 0x0e, 0xd8, 0xc9, 0x0a, 0x8c, 0x33, 0x4d, 0xd0, 0x49, 0xad, 0xd0,
	 0x22, 0x2c, 0x09, 0xd2, 0x0b, 0xe0, 0xa7, 0x9e, 0x33, 0x89, 0x10, 0xbc,
	 0xae, 0x42, 0x20, 0x60, 0x90, 0x6a, 0xe0, 0x22, 0x1d, 0xe3, 0xf3, 0xfc,
	 0x74, 0x7c, 0xcf, 0x98, 0xae, 0xcc, 0x85, 0xd6, 0xed, 0xc5, 0x2d, 0x93,
	 0xd5, 0xb7, 0x39, 0x67, 0x76, 0x16, 0x05, 0x25},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01}
};

static R_RSA_PRIVATE_KEY PRIVATE_KEY1 = {
	512,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0xc0, 0x76, 0x47, 0x97, 0xb8, 0xbe, 0xc8, 0x97,
	 0x2a, 0x0e, 0xd8, 0xc9, 0x0a, 0x8c, 0x33, 0x4d, 0xd0, 0x49, 0xad, 0xd0,
	 0x22, 0x2c, 0x09, 0xd2, 0x0b, 0xe0, 0xa7, 0x9e, 0x33, 0x89, 0x10, 0xbc,
   0xae, 0x42, 0x20, 0x60, 0x90, 0x6a, 0xe0, 0x22, 0x1d, 0xe3, 0xf3, 0xfc,
	 0x74, 0x7c, 0xcf, 0x98, 0xae, 0xcc, 0x85, 0xd6, 0xed, 0xc5, 0x2d, 0x93,
   0xd5, 0xb7, 0x39, 0x67, 0x76, 0x16, 0x05, 0x25},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x1a, 0xe3, 0x6b, 0x75, 0x22, 0xf6, 0x64, 0x87,
	 0xd9, 0xf4, 0x61, 0x0d, 0x15, 0x50, 0x29, 0x0a, 0xc2, 0x02, 0xc9, 0x29,
   0xbe, 0xdc, 0x70, 0x32, 0xcc, 0x3e, 0x02, 0xac, 0xf3, 0x7e, 0x3e, 0xbc,
	 0x1f, 0x86, 0x6e, 0xe7, 0xef, 0x7a, 0x08, 0x68, 0xd2, 0x3a, 0xe2, 0xb1,
   0x84, 0xc1, 0xab, 0xd6, 0xd4, 0xdb, 0x8e, 0xa9, 0xbe, 0xc0, 0x46, 0xbd,
	 0x82, 0x80, 0x37, 0x27, 0xf2, 0x88, 0x87, 0x01},
	{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0x02, 0xb6, 0x15,
		0xfe, 0x15, 0x92, 0x8f, 0x41, 0xb0, 0x2b, 0x58, 0x6b, 0x51, 0xc2, 0xc0,
		0x22, 0x60, 0xca, 0x39, 0x68, 0x18, 0xca, 0x4c, 0xba, 0x60, 0xbb, 0x89,
		0x24, 0x65, 0xbe, 0x35},
	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xee, 0xb6, 0x0d,
		0x54, 0x35, 0x18, 0xb4, 0xac, 0x74, 0x83, 0x4a, 0x05, 0x46, 0xc5, 0x07,
		0xf2, 0xe9, 0x1e, 0x38, 0x9a, 0x87, 0xe2, 0xf2, 0xbe, 0xcc, 0x6f, 0x8c,
		0x67, 0xd1, 0xc9, 0x31}},
	{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x48, 0x7e, 0x99,
		0xe3, 0x75, 0xc3, 0x8d, 0x73, 0x21, 0x12, 0xd9, 0x7d, 0x6d, 0xe8, 0x68,
		0x7f, 0xda, 0xfc, 0x5b, 0x6b, 0x5f, 0xb1, 0x6e, 0x72, 0x97, 0xd3, 0xbd,
		0x1e, 0x43, 0x55, 0x99},
	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xb5, 0x50, 0xde,
		0x64, 0x37, 0x77, 0x4d, 0xb0, 0x57, 0x77, 0x18, 0xed, 0x6c, 0x77, 0x07,
		0x24, 0xee, 0xe4, 0x66, 0xb4, 0x31, 0x14, 0xb5, 0xb6, 0x9c, 0x43, 0x59,
		0x1d, 0x31, 0x32, 0x81}},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x4c, 0x79, 0xc4,
	 0xb9, 0xbe, 0xa9, 0x7c, 0x25, 0xe5, 0x63, 0xc9, 0x40, 0x7a, 0x2d, 0x09,
	 0xb5, 0x73, 0x58, 0xaf, 0xe0, 0x9a, 0xf6, 0x7d, 0x71, 0xf8, 0x19, 0x8c,
	 0xb7, 0xc9, 0x56, 0xb8}
};

R_RSA_PUBLIC_KEY PUBLIC_KEY2;
R_RSA_PRIVATE_KEY PRIVATE_KEY2;
int KEYPAIR2_READY = 0;

/* If type is zero, simply print the task string, otherwise convert the
		 type to a string and print task and type.
 */
static void PrintError(char *task,int type)
{
	char *typeString, *msg[] = {
						"Recovered DES key cannot decrypt encrypted content",
						"Encrypted key length or signature length is out of range",
						"Modulus length is out of range",
						"Private key cannot encrypt message digest, or cannot decrypt encrypted key",
						"Public key cannot encrypt data encryption key, or cannot decrypt signature",
						"Signature is incorrect",
						"Unknown Error",
						NULL };

	if(type == 0) {		/* Non RSAEURO Related Error */
		puts(task);			/* Internal Deal with it */
		return;
	}

	/* Convert the type to a string if it is recognized.	 */
	switch(type) {
	case RE_KEY:
		typeString = msg[0];
		break;
	case RE_LEN:
		typeString = msg[1];
		break;
	case RE_MODULUS_LEN:
		typeString = msg[2];
		break;
	case RE_PRIVATE_KEY:
		typeString = msg[3];
		break;
	case RE_PUBLIC_KEY:
		typeString = msg[4];
		break;
	case RE_SIGNATURE:
		typeString = msg[5];
		break;

	default:
		printf("ERROR: Code 0x%04x, %s", type, msg[6]);
		fflush(stdout);
		return;
	}

	printf("ERROR: %s while %s\n", typeString, task);
	fflush(stdout);
}

static int GetCommand(char *command,unsigned int maxCommandSize,char *prompt)
{
	unsigned int i;

	printf("%s (blank to cancel): \n", prompt);
	fflush(stdout);

	fgets(command, maxCommandSize, stdin);

	/* Replace the line terminator with a '\0'.	 */

	for (i = 0; command[i] != '\0'; i++) {
		if (command[i] == '\012' || command[i] == '\015' ||	i == (maxCommandSize - 1)) {
			command[i] = '\0';
			break;
		}
	}
	return(strlen(command));
}

/*
	Initialize the random structure with all NULL seed bytes for
	test purposes.  This will NOT produce a random stream, for a
	random stream one needs a random seed.

	See: R_RandomCreate
*/

static R_RANDOM_STRUCT *InitRandomStruct(void)
{
	static unsigned char seedByte = 0;
	unsigned int bytesNeeded;
	static R_RANDOM_STRUCT randomStruct;

	R_RandomInit(&randomStruct);

	/* Initialize with all zero seed bytes, which will not yield an actual
			 random number output. */

	while (1) {
		R_GetRandomBytesNeeded(&bytesNeeded, &randomStruct);
		if(bytesNeeded == 0)
			break;

		R_RandomUpdate(&randomStruct, &seedByte, 1);
	}

	return(&randomStruct);
}





static void DoGenerateKeys(R_RANDOM_STRUCT *randomStruct)
{
	R_RSA_PROTO_KEY protoKey;
	char command[80];
	int status, keySize;

	if(GetCommand(command, sizeof(command), "  Enter Key Size in bits (508 - 1024)")) {
		sscanf(command, "%d", &protoKey.bits);

		protoKey.useFermat4 = 1;

		status = R_GeneratePEMKeys(&PUBLIC_KEY2, &PRIVATE_KEY2, &protoKey, randomStruct);
		if(status) {
			PrintError("Key Generation", status);
			return;
		}

		PrintMessage("  Public key 2 and private key 2 are now ready to use.");
		KEYPAIR2_READY = 1;

	}
}

/* Ask the user to use public key 1, 2 or 3 and point publicKey to
		 the answer.
	 Return 0 on success or 1 if user cancels by entering a blank.
 */
static int GetPublicKey (R_RSA_PUBLIC_KEY **publicKey)
{
	char command[80];

	while (1) {
		if(KEYPAIR2_READY)
			GetCommand(command, sizeof (command), "  Public key 1 or 2?");
		else
			*command = '1';

		switch (*command) {
		case '\0':
			return (0);

		case '1':
			*publicKey = &PUBLIC_KEY1;
			return (1);

		case '2':
			if (!KEYPAIR2_READY)
				break;
			*publicKey = &PUBLIC_KEY2;
			return (1);

		default:
			if (KEYPAIR2_READY)
				PrintError ("ERROR: Please enter 1 or 2.  Try again.", 0);
			break;
		}
	}
}

/* Ask the user to use private key 1, 2 or 3 and point privateKey to
		 the answer.
	 Return 0 on success or 1 if user cancels by entering a blank.
 */
static int GetPrivateKey(R_RSA_PRIVATE_KEY **privateKey)
{
	char command[80];

	while (1) {
		if (KEYPAIR2_READY)
			GetCommand(command, sizeof (command), "  Public key 1 or 2?");
		else
			*command = '1';

		switch (*command) {
		case '\0':
			return (0);

		case '1':
			*privateKey = &PRIVATE_KEY1;
			return (1);

		case '2':
			if (!KEYPAIR2_READY)
				break;
			*privateKey = &PRIVATE_KEY2;
			return (1);

		default:
			if (KEYPAIR2_READY)
				PrintError ("ERROR: Please enter 1 or 2.  Try again.", 0);
			break;
		}
	}
}


void main()
{
		char command[80];
	int done = 0;

unsigned char *raw = (unsigned char*)malloc(500);
unsigned char *out = (unsigned char*)malloc(500);
unsigned char *deraw = (unsigned char*)malloc(500);
int raw_len = 0;
int out_len = 0;
int deraw_len = 0;

	R_RANDOM_STRUCT *randomStruct;

	randomStruct = InitRandomStruct();/* setup random object */

	printf("input raw data :less than 500 characters.\n");
	scanf("%s",raw);
	raw_len=strlen(raw);
	out_len=raw_len;
	deraw_len=raw_len;

	raw[raw_len]='\0';
	deraw[deraw_len]='\0';
/*
//RSA encodeing

	RSAPublicEncrypt(out,&out_len,raw,raw_len,&PUBLIC_KEY1,randomStruct);
	out[out_len]='\0';
	printf("endcode ::%s\n",out);
	RSAPrivateDecrypt(deraw,&deraw_len,out,out_len,&PRIVATE_KEY1);	
	printf("dedcode ::%s\n",deraw);

*/
	RSAPrivateEncrypt(out,&out_len,raw,raw_len,&PRIVATE_KEY1);
	out[out_len]='\0';
	printf("endcode ::%s\n",out);
	RSAPublicDecrypt(deraw,&deraw_len,out,out_len,&PUBLIC_KEY1);	
	printf("dedcode ::%s\n",deraw);
	
  }
